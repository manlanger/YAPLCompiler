/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(YaplParser)

package yapl;

import yapl.interfaces.*;
import yapl.lib.CompilerMessage;
import yapl.lib.YAPLException;
import yapl.compiler.ParseException;
import yapl.compiler.TokenMgrError;
import yapl.impl.*;
import yapl.types.BoolType;
import yapl.types.IntType;

public class YaplParser
{
    private static String programName = "";
    private static Symboltable symbolTable = new SymbolTableImpl();
    private static CodeGen codeGen = new CodeGenImpl();
    private static final String predefinedProcedures = "Procedure void writeint(int i);Procedure void writebool(bool b);Procedure void writeln();Procedure int readint();";

  	public static void main(String args []) throws ParseException
  	{
      	YaplParser parser = null;

      	// init predefined procedures
      	try {
      		parser = new YaplParser(new java.io.StringReader(predefinedProcedures));
      		parser.PreDefinedProcedures();
      	} catch(Throwable e) {
	        System.out.println ("Predefined procedure init failed! " + e.getMessage());
			return;
	    }

	    if(args.length == 0){
	    	System.out.println ("YaplParser: Reading input ...");
	    	parser = new YaplParser(System.in);
	    }
	    else if(args.length == 1){
	        try {
	          parser.ReInit(new java.io.FileInputStream(args[0]));
	          System.out.println ("YaplParser: Reading the file " + args[0] + " ..." );
	        } catch(java.io.FileNotFoundException e) {
	        	System.out.println ("ExampleParser: The file " + args[0] + " was not found.");
	        	return;
	        }
	    }

		if (parser == null) {
		  	System.out.println ("Parser initialization failed!");
		} else {
		    try {
		        parser.Start();
		        CompilerMessage.printOK(programName);
		    }catch (Throwable e)
		    {
                CompilerMessage.printError((CompilerError) e, programName);
		    }
		}
  	}
}

PARSER_END(YaplParser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

SPECIAL_TOKEN :
{
  <COMMENT: "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/"> |
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
}

/*
Symbols
*/
TOKEN :
{
  < HASH : "#" >
| < PERC : "%" >
| < LEFTPAR : "(" >
| < RIGHTPAR : ")" >
| < MULT : "*" >
| < PLUS : "+" >
| < COMMA : "," >
| < MINUS : "-" >
| < DOT : "." >
| < SLASH : "/" >
| < LESSTHAN : "<" >
| < GREATERTHAN : ">" >
| < LEFTBRACKET : "[" >
| < RIGHTBRACKET : "]" >
| < OR : "Or" >
| < AND : "And" >
| < INT : "int" >
| < NEW : "new" >
| < TRUE : "True" >
| < FALSE : "False" >
| < BOOL : "bool" >
| < IF : "If" >
| <SEMICOLOM : ";" >
| <WHILE : "While" >
| <VOID : "void" >
| <ELSE : "Else" >
| <END : "End" >
| <WRITE : "Write" >
| <PROGRAM : "Program" >
| <DECLARE: "Declare" >
| <EQUALS: "=" >
| <CONST: "Const">
| <PROCEDURE: "Procedure" >
| <BEGIN: "Begin" >
| <RETURN: "Return" >
| <COLOMEQUALS: ":=">
| <DO:"Do">
| <THEN:"Then">
| <ENDIF:"EndIf" >
| <RECORD:"Record" >
| <ENDRECORD:"EndRecord" >
| <ENDWHILE: "EndWhile" >
}

/*
letter = "A" .. "Z" | "a" .. "z" | "_" .
digit = "0" .. "9" .
otherchar = "+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
| "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
| "[" | "]" | "{" | "}" | "\" | "@" | "&" | "^" | "|" .
ident = letter { letter | digit } .
number = digit { digit } .
string = '"' { " " | letter | digit | otherchar } '"' .
*/

TOKEN :
{
  < #LETTER : (["A"-"Z","a"-"z","_"]) >
| < #DIGIT : [ "0"-"9" ] >
| < OTHERCHAR : "+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!" | "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")" | "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|" >
| < IDENT : < LETTER > ( < LETTER > | < DIGIT > )* >
| < NUMBER : < DIGIT > ( < DIGIT > )* >
| < STRING : "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR > )* "\"" > 
}

/*
RelOp = "<" | "<=" | ">=" | ">" .
EqualOp = "==" | "!=" .
AddOp = "+" | "-" .
MulOp = "*" | "/" | "%" .
*/

Token RelOp() :
{
	Token token;
}
{
  	( token = "<" | token = "<=" | token = ">=" | token = ">" )
  	{
		return token;
	}
}

Token EqualOp() :
{
	Token token;
}
{
  	( token = "==" | token = "!=" )
    {
		return token;
	}
}

Token AddOp() :
{
	Token token;
}
{
  	( token = "+" | token = "-" )
  	{
  		return token;
  	}
}

Token MulOp() :
{
	Token token;
}
{
  	( token = "*" | token = "/" | token = "%" )
  	{
    	return token;
  	}
}

/*
Literal = "True" | "False" | number .
Selector = ( "[" Expr "]" | "." ident ) [ Selector ] .
ArrayLen = "#" ident [ Selector ] .
*/

Attrib Literal() :
{
	Token token;
	Attrib attrib;
}
{
  	<TRUE>
	{
	  	attrib = new AttribImpl(Attrib.Constant, new BoolType(true));
		return attrib;
	}
	
	| <FALSE>
	{
		attrib = new AttribImpl(Attrib.Constant, new BoolType(false));
		return attrib;
	}
		
	| token = <NUMBER>
	{
	 	attrib = new AttribImpl(Attrib.Constant, new IntType(Integer.parseInt(token.image)));
	  	return attrib;
	}
}

void Selector() throws YAPLException:
{}
{
  ( "[" Expr() "]" | "." < IDENT > ) [ Selector() ]
}

Attrib ArrayLen() throws YAPLException:
{
	Token token;
	Attrib attrib;
}
{
  	"#" token = <IDENT>
  	{
		Symbol symbol = symbolTable.lookup(token.image);
		attrib = new AttribImpl(symbol);
  		
    	if (symbol == null) {
    		throw new YAPLException("identifier " + token.image + " not declared", CompilerError.IdentNotDecl, token);
    	}

    	if (symbol.getKind() == Symbol.Constant) {
    	  	throw new YAPLException("illegal use of constant " + symbol.getName(), CompilerError.SymbolIllegalUse, token);
    	}

    	if (symbol.getKind() == Symbol.Procedure) {
    	  	throw new YAPLException("illegal use of procedure " + symbol.getName(), CompilerError.SymbolIllegalUse, token);
    	}

    	return codeGen.arrayLength(attrib);
  	} [ Selector() ]
  	{
  		return attrib;
  	}
}

/*
PrimaryExpr = Literal | "(" Expr ")" | ProcedureCall | ident [ Selector ] | ArrayLen .
UnaryExpr = [AddOp] PrimaryExpr .
MulExpr = UnaryExpr { MulOp UnaryExpr } .
AddExpr = MulExpr { AddOp MulExpr } .
RelExpr = AddExpr [ RelOp AddExpr ] .
*/

Attrib PrimaryExpr() throws YAPLException:
{
	Token token;
	Attrib attrib = null;
}
{
	( attrib = Literal() | "(" attrib = Expr() ")" | LOOKAHEAD(2) ProcedureCall() | token = <IDENT>
  	{
  		Symbol symbol = symbolTable.lookup(token.image);
  		attrib = new AttribImpl(symbol);
  		
    	if (symbol == null) {
    		throw new YAPLException("identifier " + token.image + " not declared", CompilerError.IdentNotDecl, token);
    	}

    	if (symbol.getKind() == Symbol.Procedure) {
    	  	throw new YAPLException("illegal use of procedure " + symbol.getName(), CompilerError.SymbolIllegalUse, token);
    	}
  	}
  	[ Selector() ] | attrib = ArrayLen() )
  	{
  		return attrib;
  	}
}

Attrib UnaryExpr() throws YAPLException:
{
  	Token op = null;
	Attrib attrib;
}
{
  	[ op = AddOp() ] attrib = PrimaryExpr()
  	{
  	  	codeGen.op1(op, attrib);
		return attrib;
  	}
}

Attrib MulExpr() throws YAPLException:
{
	Attrib a1, a2;
	Token op;
}
{
  	a1 = UnaryExpr() ( op = MulOp() a2 = UnaryExpr()
  	{
  		codeGen.op2(a1, op, a2);
  	} )*
  	{
  		return a1;
  	}
}

Attrib AddExpr() throws YAPLException:
{  
	Attrib a1, a2;
	Token op;
}
{
  	a1 = MulExpr() ( op = AddOp() a2 = MulExpr()
  	{
  		codeGen.op2(a1, op, a2);
  	} )*
  	{
  		return a1;
  	}
}

Attrib RelExpr() throws YAPLException:
{
  	Attrib a1, a2;
	Token op;
}
{
  	a1 = AddExpr() [ op = RelOp() a2 = AddExpr()
  	{
  		codeGen.relOp(a1, op, a2);
  	} ]
  	{
  		return a1;
  	}
}

/*
EqualExpr = RelExpr [ EqualOp RelExpr ] .
CondAndExpr = EqualExpr { "And" EqualExpr } .
CreationExpr = "new" NonArrayType { "[" Expr "]" } .
Expr = CondAndExpr { "Or" CondAndExpr } | CreationExpr .
*/

Attrib EqualExpr() throws YAPLException:
{
   	Attrib a1, a2;
	Token op;
}
{
	a1 = RelExpr() [ op = EqualOp() a2 = RelExpr()
	{
		codeGen.equalOp(a1, op, a2);
	} ]
	{
		return a1;
	}
}

Attrib CondAndExpr() throws YAPLException:
{
	Attrib a1, a2;
}
{
  	a1 = EqualExpr() ( "And" a2 = EqualExpr() )*
  	{
  		return a1;
  	}
}

Attrib CreationExpr() throws YAPLException:
{
  	Attrib attrib;
}
{
  	"new" attrib = NonArrayType() ( "[" Expr() "]" )*
  	{
  		return attrib;
  	}    
}

Attrib Expr() throws YAPLException:
{
	Attrib a1, a2;
}
{
  	( a1 = CondAndExpr()  ( "Or" a2 = CondAndExpr() )* | a1 = CreationExpr())
  	{
  		return a1;
  	}
}

/*
ArgumentList = Expr { "," Expr } .
ProcedureCall = ident "(" [ ArgumentList ] ")" .
*/

void ArgumentList() throws YAPLException:
{}
{
  Expr() ( "," Expr() )*
}

void ProcedureCall() throws YAPLException:
{
	Token token;
}
{
  	token = <IDENT>
  	{
		Symbol symbol = symbolTable.lookup(token.image);

    	if (symbol == null) {
    		throw new YAPLException("identifier " + token.image + " not declared", CompilerError.IdentNotDecl, token);
    	}

    	if (symbol.getKind() != Symbol.Procedure) {
    	  	throw new YAPLException("illegal use of variable " + token.image, CompilerError.SymbolIllegalUse, token);
    	}
			
  	} "(" [ ArgumentList() ] ")"
}

void Assignment() throws YAPLException:
{
	Token token;
}
{
    token = < IDENT >
    {
    	Symbol symbol = symbolTable.lookup(token.image);

    	if (symbol == null) {
    		throw new YAPLException("identifier " + token.image + " not declared", CompilerError.IdentNotDecl, token);
    	}

    	if (symbol.getKind() != Symbol.Variable && symbol.getKind() != Symbol.Parameter) {
    		throw new YAPLException("illegal use of " + symbol.getKindString() + " " + symbol.getName(), CompilerError.SymbolIllegalUse, token);
    	}
    }
    [ Selector() ] ":=" Expr()
}

void IfStatement() throws YAPLException:
{}
{
    "If" Expr() "Then" StatementList() [ "Else" StatementList() ] "EndIf"
}

void WhileStatement() throws YAPLException:
{}
{
    "While" Expr() "Do" StatementList() "EndWhile"
}

void ReturnStatement() throws YAPLException:
{}
{
    "Return" [ Expr() ]
}

void WriteStatement() :
{}
{
    "Write" < STRING >
}

void Statement() throws YAPLException:
{}
{
    IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() |  LOOKAHEAD(2) ProcedureCall() | Block()
}

void StatementList() throws YAPLException:
{}
{
    ( Statement() ";" )*
}

void Block() throws YAPLException:
{}
{
    {
    	symbolTable.openScope(false);
    }
    [ Decl() ] "Begin" StatementList() "End"
    {
    	symbolTable.closeScope();
    }
}

/*
NonArrayType = "int" | "bool" | ident .
*/

Attrib NonArrayType() throws YAPLException:
{
	Token token;
	Attrib attrib = null;
}
{
	( "int" | "bool" | token = <IDENT>
	{
		Symbol symbol = symbolTable.lookup(token.image);
		attrib = new AttribImpl(symbol);
  		
    	if (symbol == null) {
    		throw new YAPLException("identifier " + token.image + " not declared", CompilerError.IdentNotDecl, token);
    	}

    	if (symbol.getKind() == Symbol.Constant) {
    		throw new YAPLException("illegal use of constant " + symbol.getName(), CompilerError.SymbolIllegalUse, token);
    	}
	}
	)
	{
		return attrib;
	}
}

void Type() throws YAPLException:
{}
{
    NonArrayType() ( "[" "]" )*
}

void ReturnType() throws YAPLException:
{}
{
    "void" | Type()
}

void ConstDecl() throws YAPLException:
{
  	Symbol symbol;
	Token token;
	Attrib attrib;
}
{
    "Const" token = <IDENT>
    {
      	symbol = new SymbolImpl(token.image, Symbol.Constant);
      	
    	try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	} 
    }
    "=" attrib = Literal()
    {
    	symbol.setType(attrib.getType());
    } ";"
}

void VarDecl() throws YAPLException:
{
	Token token;
	Symbol symbol;
}
{
    Type() token = <IDENT>
    {
      	symbol = new SymbolImpl(token.image, Symbol.Variable);

      	try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	} 
    }
    ( "," token = <IDENT>
    {
      	symbol = new SymbolImpl(token.image, Symbol.Variable);
    	
		try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	}
    }
    )* ";"
}

void TypeDecl() throws YAPLException:
{
	Token token;
}
{
    "Record" token = <IDENT>
    {
    	Symbol symbol = new SymbolImpl(token.image, Symbol.Typename);

      	try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	}

    	symbolTable.openScope(false);
    }
    VarDecl() ( VarDecl() )* "EndRecord"
    {
    	symbolTable.closeScope();
    } ";"
}

void Decl() throws YAPLException:
{}
{
    "Declare" ( ConstDecl() | VarDecl() | TypeDecl() )*
}

void FormalParam() throws YAPLException:
{
	Token token;
}
{
    Type() token = <IDENT>
    {
    	Symbol symbol = new SymbolImpl(token.image, Symbol.Parameter);
    	
		try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	} 
    }
}

void FormalParamList() throws YAPLException:
{}
{
    FormalParam() ( "," FormalParam() )*
}

void Procedure() throws YAPLException :
{
  	Token start_proc;
  	Token end_proc;
}
{
    "Procedure" ReturnType() start_proc = <IDENT>
    {
    	Symbol symbol = new SymbolImpl(start_proc.image, Symbol.Procedure);
    	
    	try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	}

    	symbolTable.openScope(false);
    	symbolTable.setParentSymbol(symbol);
    }
     "(" [ FormalParamList() ] ")" Block() end_proc = <IDENT>
     {
       	if (!start_proc.image.equals(end_proc.image))
       		throw new YAPLException("End " + end_proc.image + " does not match Procedure " + start_proc.image, CompilerError.EndIdentMismatch, end_proc);
       		
     	symbolTable.closeScope();
     } ";"
}

void Program() throws YAPLException:
{
 	Token start_prog;
  	Token end_prog;
}
{
    "Program" start_prog = <IDENT>
    {
    	programName = start_prog.toString();
    	Symbol symbol = new SymbolImpl(start_prog.image, Symbol.Program);
		symbolTable.openScope(true);
    	symbolTable.setParentSymbol(symbol);
    }
    (Decl() | Procedure())*
    "Begin" StatementList() "End" end_prog = <IDENT>
    {
    	if (!start_prog.image.equals(end_prog.image))
       		throw new YAPLException("End " + end_prog.image + " does not match Program " + start_prog.image, CompilerError.EndIdentMismatch, end_prog);
    } "."
}

void PreDefinedProcedures() throws YAPLException:
{}
{
  	(PreDefinedProcedure())*
}

void PreDefinedProcedure() throws YAPLException:
{
	Token token;
} 
{
	"Procedure" ReturnType() token = <IDENT>
    {
    	Symbol symbol = new SymbolImpl(token.image, Symbol.Procedure);

    	symbolTable.openScope(true);
    	
    	try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	}

    	symbolTable.setParentSymbol(symbol);
    }
    "(" [ FormalParamList() ] ")"
    ";"
}

void Start() throws YAPLException:
{}
{
    Program() <EOF>
}