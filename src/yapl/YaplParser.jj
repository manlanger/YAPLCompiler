/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(YaplParser)

package yapl;

import yapl.interfaces.*;
import yapl.lib.CompilerMessage;
import yapl.lib.YAPLException;
import yapl.compiler.ParseException;
import yapl.compiler.TokenMgrError;
import yapl.impl.SymbolImpl;
import yapl.impl.SymbolTableImpl;

public class YaplParser
{
    private static String programName = "";
    private static Symboltable symbolTable = new SymbolTableImpl();

  	public static void main(String args []) throws ParseException
  	{
      	YaplParser parser = null;

	    if(args.length == 0){
	    	System.out.println ("YaplParser: Reading input ...");
	    	parser = new YaplParser(System.in);
	    }
	    else if(args.length == 1){
	    	//System.out.println ("YaplParser: Reading the file " + args[0] + " ..." );

	        try {
	          parser = new YaplParser(new java.io.FileInputStream(args[0]));
	        }

	        catch(java.io.FileNotFoundException e) {
	        	System.out.println ("ExampleParser: The file " + args[0] + " was not found.");
	        	return;
	        }
	    }

		if (parser == null) {
		  	System.out.println ("Parser initialization failed!");
		} else {
		    try {
		        parser.Start();
		        CompilerMessage.printOK(programName);
		    }catch (Throwable e)
		    {

                CompilerMessage.printError((CompilerError) e, programName);
		    }

		}
  	}
}

PARSER_END(YaplParser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

SPECIAL_TOKEN :
{
  <COMMENT: "/*" (~[])* "*/"> |
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
}

/*
Symbols
*/
TOKEN :
{
  < HASH : "#" >
| < PERC : "%" >
| < LEFTPAR : "(" >
| < RIGHTPAR : ")" >
| < MULT : "*" >
| < PLUS : "+" >
| < COMMA : "," >
| < MINUS : "-" >
| < DOT : "." >
| < SLASH : "/" >
| < LESSTHAN : "<" >
| < GREATERTHAN : ">" >
| < LEFTBRACKET : "[" >
| < RIGHTBRACKET : "]" >
| < OR : "Or" >
| < AND : "And" >
| < INT : "int" >
| < NEW : "new" >
| < TRUE : "True" >
| < FALSE : "False" >
| < BOOL : "bool" >
| < IF : "If" >
| <SEMICOLOM : ";" >
| <WHILE : "While" >
| <VOID : "void" >
| <ELSE : "Else" >
| <END : "End" >
| <WRITE : "Write" >
| <PROGRAM : "Program" >
| <DECLARE: "Declare" >
| <EQUALS: "=" >
| <CONST: "Const">
| <PROCEDURE: "Procedure" >
| <BEGIN: "Begin" >
| <RETURN: "Return" >
| <COLOMEQUALS: ":=">
| <DO:"Do">
| <THEN:"Then">
| <ENDIF:"EndIf" >
| <RECORD:"Record" >
| <ENDRECORD:"EndRecord" >
| <ENDWHILE: "EndWhile" >
| <WRITE_INT: "writeint">
| <WRITE_BOOL: "writebool">
| <WRITE_LN: "writeln">
| <READ_INT: "readint">
}

/*
letter = "A" .. "Z" | "a" .. "z" | "_" .
digit = "0" .. "9" .
otherchar = "+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
| "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
| "[" | "]" | "{" | "}" | "\" | "@" | "&" | "^" | "|" .
ident = letter { letter | digit } .
number = digit { digit } .
string = '"' { " " | letter | digit | otherchar } '"' .
*/

TOKEN :
{
  < #LETTER : (["A"-"Z","a"-"z","_"]) >
| < #DIGIT : [ "0"-"9" ] >
| < OTHERCHAR : "+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!" | "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")" | "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|" >
| < IDENT : < LETTER > ( < LETTER > | < DIGIT > )* >
| < NUMBER : < DIGIT > ( < DIGIT > )* >
| < STRING : "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR > )* "\"" > 
}

/*
RelOp = "<" | "<=" | ">=" | ">" .
EqualOp = "==" | "!=" .
AddOp = "+" | "-" .
MulOp = "*" | "/" | "%" .
*/

void RelOp() :
{}
{
  ( "<" | "<=" | ">=" | ">" )
}

void EqualOp() :
{}
{
  ( "==" | "!=" )
}

void AddOp() :
{}
{
  ( "+" | "-" )
}

void MulOp() :
{}
{
  ( "*" | "/" | "%" )
}

/*
Literal = "True" | "False" | number .
Selector = ( "[" Expr "]" | "." ident ) [ Selector ] .
ArrayLen = "#" ident [ Selector ] .
*/

void Literal() :
{}
{
  ( "True" | "False" | < NUMBER > )
}

void Selector() throws YAPLException:
{}
{
  ( "[" Expr() "]" | "." < IDENT > ) [ Selector() ]
}

void ArrayLen() throws YAPLException:
{
	Token token;
}
{
  	"#" token = <IDENT>
  	{
		Symbol symbol = symbolTable.lookup(token.image);
  		
    	if (symbol == null) {
    		throw new YAPLException("identifier " + token.image + " not declared", CompilerError.IdentNotDecl, token);
    	}
  	} [ Selector() ]
}

/*
PrimaryExpr = Literal | "(" Expr ")" | ProcedureCall | ident [ Selector ] | ArrayLen .
UnaryExpr = [AddOp] PrimaryExpr .
MulExpr = UnaryExpr { MulOp UnaryExpr } .
AddExpr = MulExpr { AddOp MulExpr } .
RelExpr = AddExpr [ RelOp AddExpr ] .
*/

void PrimaryExpr() throws YAPLException:
{
	Token token;
}
{
	( Literal() | "(" Expr() ")" | LOOKAHEAD(2) ProcedureCall() | token = <IDENT>
  	{
  		Symbol symbol = symbolTable.lookup(token.image);
  		
    	if (symbol == null) {
    		throw new YAPLException("identifier " + token.image + " not declared", CompilerError.IdentNotDecl, token);
    	}

    	if (symbol.getKind() == Symbol.Procedure) {
    	  	throw new YAPLException("illegal use of procedure " + symbol.getName(), CompilerError.SymbolIllegalUse, token);
    	}
  	}
  	[ Selector() ] | ArrayLen() )
}

void UnaryExpr() throws YAPLException:
{}
{
  [ AddOp() ] PrimaryExpr()
}

void MulExpr() throws YAPLException:
{}
{
  UnaryExpr() ( MulOp() UnaryExpr() )*
}

void AddExpr() throws YAPLException:
{}
{
  MulExpr() ( AddOp() MulExpr() )*
}

void RelExpr() throws YAPLException:
{}
{
  AddExpr() [ RelOp() AddExpr() ]
}

/*
EqualExpr = RelExpr [ EqualOp RelExpr ] .
CondAndExpr = EqualExpr { "And" EqualExpr } .
CreationExpr = "new" NonArrayType { "[" Expr "]" } .
Expr = CondAndExpr { "Or" CondAndExpr } | CreationExpr .
*/

void EqualExpr() throws YAPLException:
{}
{
  RelExpr() [ EqualOp() RelExpr() ]
}

void CondAndExpr() throws YAPLException:
{}
{
  EqualExpr() ( "And" EqualExpr() )*
}

void CreationExpr() throws YAPLException:
{}
{
  "new" NonArrayType() ( "[" Expr() "]" )*
}

void Expr() throws YAPLException:
{}
{
  CondAndExpr()  ( "Or" CondAndExpr() )* | CreationExpr()
}

/*
ArgumentList = Expr { "," Expr } .
ProcedureCall = ident "(" [ ArgumentList ] ")" .
*/

void ArgumentList() throws YAPLException:
{}
{
  Expr() ( "," Expr() )*
}

void ProcedureCall() throws YAPLException:
{
	Token token;
}
{
  	(PreDefinedProcedures() | token = <IDENT>
  	{
		Symbol symbol = symbolTable.lookup(token.image);

    	if (symbol == null) {
    		throw new YAPLException("identifier " + token.image + " not declared", CompilerError.IdentNotDecl, token);
    	}

    	if (symbol.getKind() != Symbol.Procedure) {
    	  	throw new YAPLException("illegal use of variable " + token.image, CompilerError.SymbolIllegalUse, token);
    	}
			
  	}) "(" [ ArgumentList() ] ")"
}

void Assignment() throws YAPLException:
{
	Token token;
}
{
    token = < IDENT >
    {
    	Symbol symbol = symbolTable.lookup(token.image);

    	if (symbol == null) {
    		throw new YAPLException("identifier " + token.image + " not declared", CompilerError.IdentNotDecl, token);
    	}
    }
    [ Selector() ] ":=" Expr()
}

void IfStatement() throws YAPLException:
{}
{
    "If" Expr() "Then" StatementList() [ "Else" StatementList() ] "EndIf"
}

void WhileStatement() throws YAPLException:
{}
{
    "While" Expr() "Do" StatementList() "EndWhile"
}

void ReturnStatement() throws YAPLException:
{}
{
    "Return" [ Expr() ]
}

void WriteStatement() :
{}
{
    "Write" < STRING >
}

void Statement() throws YAPLException:
{}
{
    IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() |  LOOKAHEAD(2) ProcedureCall() | Block()
}

void StatementList() throws YAPLException:
{}
{
    ( Statement() ";" )*
}

void Block() throws YAPLException:
{}
{
    {
    	symbolTable.openScope(false);
    }
    [ Decl() ] "Begin" StatementList() "End"
    {
    	symbolTable.closeScope();
    }
}

/*
NonArrayType = "int" | "bool" | ident .
*/

void NonArrayType() :
{}
{
  ( "int" | "bool" | < IDENT > )
}

void Type() :
{}
{
    NonArrayType() ( "[" "]" )*
}

void ReturnType() :
{}
{
    "void" | Type()
}

void ConstDecl() throws YAPLException:
{
	Token token;
}
{
    "Const" token = <IDENT>
    {
      	Symbol symbol = new SymbolImpl(token.image, Symbol.Constant);
      	
    	try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	} 
    }
    "=" Literal() ";"
}

void VarDecl() throws YAPLException:
{
	Token token;
	Symbol symbol;
}
{
    Type() token = <IDENT>
    {
      	symbol = new SymbolImpl(token.image, Symbol.Variable);

      	try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	} 
    }
    ( "," token = <IDENT>
    {
      	symbol = new SymbolImpl(token.image, Symbol.Variable);
    	
		try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	}
    }
    )* ";"
}

void TypeDecl() throws YAPLException:
{}
{
    "Record" <IDENT> VarDecl() ( VarDecl() )* "EndRecord" ";"
}

void Decl() throws YAPLException:
{}
{
    "Declare" ( ConstDecl() | VarDecl() | TypeDecl() )*
}

void FormalParam() throws YAPLException:
{
	Token token;
}
{
    Type() token = <IDENT>
    {
    	Symbol symbol = new SymbolImpl(token.image, Symbol.Parameter);
    	
		try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	} 
    }
}

void FormalParamList() throws YAPLException:
{}
{
    FormalParam() ( "," FormalParam() )*
}

void Procedure() throws YAPLException :
{
  	Token start_proc;
  	Token end_proc;
}
{
    "Procedure" ReturnType() start_proc = <IDENT>
    {
    	Symbol symbol = new SymbolImpl(start_proc.image, Symbol.Procedure);

		try { 
    		symbolTable.addSymbol(symbol);
    	} catch (YAPLException e) {
    	  	throw new YAPLException(e.getMessage(), CompilerError.SymbolExists, token);
    	}

    	symbolTable.openScope(false);
    	symbolTable.setParentSymbol(symbol);
    }
     "(" [ FormalParamList() ] ")" Block() end_proc = <IDENT>
     {
       	if (!start_proc.image.equals(end_proc.image))
       		throw new YAPLException("procedure name does not match", CompilerError.EndIdentMismatch, end_proc);
       		
     	symbolTable.closeScope();
     } ";"
}

void Program() throws YAPLException:
{
 	Token start_prog;
  	Token end_prog;
}
{

    "Program" start_prog = <IDENT>
    {
    	programName = start_prog.toString();
    	Symbol symbol = new SymbolImpl(start_prog.image, Symbol.Program);
		symbolTable.openScope(true);
    	symbolTable.setParentSymbol(symbol);
    }
    (Decl() | Procedure())*
    "Begin" StatementList() "End" end_prog = <IDENT>
    {
    	if (!start_prog.image.equals(end_prog.image))
       		throw new YAPLException("program name does not match", CompilerError.EndIdentMismatch, end_prog);
    } "."
}

void PreDefinedProcedures():
{}
{
    "writeint"|"writebool"|"writeln"|"readint"
}

void Start() throws YAPLException:
{}
{
    Program() <EOF>
}

/*
void Start() : { Token t; } {
{
  do {
	t = getNextToken();
	System.out.println("Token: " + t.toString());
	} while (t.kind != EOF);
}
<EOF>
}*/