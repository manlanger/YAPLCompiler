/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(YaplParser)

public class YaplParser
{
  	public static void main(String args []) throws ParseException
  	{
      	YaplParser parser = null;

	    if(args.length == 0){
	    	System.out.println ("YaplParser: Reading input ...");
	    	parser = new YaplParser(System.in);
	    }
	    else if(args.length == 1){
	    	System.out.println ("YaplParser: Reading the file " + args[0] + " ..." );

	        try {
	          parser = new YaplParser(new java.io.FileInputStream(args[0]));
	        }

	        catch(java.io.FileNotFoundException e) {
	        	System.out.println ("ExampleParser: The file " + args[0] + " was not found.");
	        	return;
	        }
	    }

		if (parser == null) {
		  	System.out.println ("Parser initialization failed!");
		} else {
		  	parser.Start();
		}
  	}
}

PARSER_END(YaplParser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

SPECIAL_TOKEN :
{
  <COMMENT: "/*" (~["\n","\r"])* "*/">
}

/*
Symbols
*/
TOKEN :
{
  < HASH : "#" >
| < PERC : "%" >
| < LEFTPAR : "(" >
| < RIGHTPAR : ")" >
| < MULT : "*" >
| < PLUS : "+" >
| < COMMA : "," >
| < MINUS : "-" >
| < DOT : "." >
| < SLASH : "/" >
| < LESSTHAN : "<" >
| < GREATERTHAN : ">" >
| < LEFTBRACKET : "[" >
| < RIGHTBRACKET : "]" >
| < OR : "Or" >
| < AND : "And" >
| < INT : "int" >
| < NEW : "new" >
| < TRUE : "True" >
| < FALSE : "False" >
| < BOOL : "bool" >
}

/*
letter = "A" .. "Z" | "a" .. "z" | "_" .
digit = "0" .. "9" .
otherchar = "+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
| "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
| "[" | "]" | "{" | "}" | "\" | "@" | "&" | "^" | "|" .
ident = letter { letter | digit } .
number = digit { digit } .
string = '"' { " " | letter | digit | otherchar } '"' .
*/

TOKEN :
{
  < #LETTER : (["A"-"Z","a"-"z","_"]) >
| < #DIGIT : [ "0"-"9" ] >
| < OTHERCHAR : "+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!" | "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")" | "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|" >
| < IDENT : < LETTER > ( < LETTER > | < DIGIT > )* >
| < NUMBER : < DIGIT > ( < DIGIT > )* >
| < STRING : "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR > )* "\"" > 
}

/*
RelOp = "<" | "<=" | ">=" | ">" .
EqualOp = "==" | "!=" .
AddOp = "+" | "-" .
MulOp = "*" | "/" | "%" .
*/

void RelOp() :
{}
{
  ( "<" | "<=" | ">=" | ">" )
}

void EqualOp() :
{}
{
  ( "==" | "!=" )
}

void AddOp() :
{}
{
  ( "+" | "-" )
}

void MulOp() :
{}
{
  ( "*" | "/" | "%" )
}

/*
Literal = "True" | "False" | number .
Selector = ( "[" Expr "]" | "." ident ) [ Selector ] .
ArrayLen = "#" ident [ Selector ] .
*/

void Literal() :
{}
{
  ( "True" | "False" | < NUMBER > )
}

void Selector() :
{}
{
  ( "[" Expr() "]" | "." < IDENT > ) [ Selector() ]
}

void ArrayLen() :
{}
{
  "#" < IDENT > [ Selector() ]
}

/*
PrimaryExpr = Literal | "(" Expr ")" | ProcedureCall | ident [ Selector ] | ArrayLen .
UnaryExpr = [AddOp] PrimaryExpr .
MulExpr = UnaryExpr { MulOp UnaryExpr } .
AddExpr = MulExpr { AddOp MulExpr } .
RelExpr = AddExpr [ RelOp AddExpr ] .
*/

void PrimaryExpr() :
{}
{
  ( Literal() | "(" Expr() ")" | LOOKAHEAD(2) ProcedureCall() | < IDENT > [ Selector() ] | ArrayLen() )
}

void UnaryExpr() :
{}
{
  [ AddOp() ] PrimaryExpr()
}

void MulExpr() :
{}
{
  UnaryExpr() ( MulOp() UnaryExpr() )*
}

void AddExpr() :
{}
{
  MulExpr() ( AddOp() MulExpr() )*
}

void RelExpr() :
{}
{
  AddExpr() [ RelOp() AddExpr() ]
}

/*
EqualExpr = RelExpr [ EqualOp RelExpr ] .
CondAndExpr = EqualExpr { "And" EqualExpr } .
CreationExpr = "new" NonArrayType { "[" Expr "]" } .
Expr = CondAndExpr { "Or" CondAndExpr } | CreationExpr .
*/

void EqualExpr() :
{}
{
  RelExpr() [ EqualOp() RelExpr() ]
}

void CondAndExpr() :
{}
{
  EqualExpr() ( "And" EqualExpr() )*
}

void CreationExpr() :
{}
{
  "new" NonArrayType() ( "[" Expr() "]" )*
}

void Expr() :
{}
{
  CondAndExpr() [ ( "Or" CondAndExpr() )+ | CreationExpr() ]
}

/*
ArgumentList = Expr { "," Expr } .
ProcedureCall = ident "(" [ ArgumentList ] ")" .
*/

void ArgumentList() :
{}
{
  Expr() ( "," Expr() )*
}

void ProcedureCall() :
{}
{
  < IDENT > "(" [ ArgumentList() ] ")"
}

/*
NonArrayType = "int" | "bool" | ident .
*/

void NonArrayType() :
{}
{
  ( "int" | "bool" | < IDENT > )
}


void Start() : { Token t; } {
{
  do {
	t = getNextToken();
	System.out.println("Token: " + t.toString());
	} while (t.kind != EOF);
}
<EOF>
}